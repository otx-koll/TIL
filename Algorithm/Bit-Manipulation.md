# 비트 조작

비트 조작은 바이트 내에서 비트 또는 비트 그룹을 조작하는 프로세스이다. 기존 연산자의 우선 순위로는 수행하기 어렵거나 불가능한 데이터에 대한 작업을 수행하는 데 자주 사용된다. 

비트 조작은 많은 곳에 응용하여 사용된다.

- 임베디드 시스템의 성능이나 공간을 최적화할 수 있다.
- XOR 연산자(^)를 사용하여 패리티 검사를 수행할 수 있다.
- 데이터 암호화 및 압축에 자주 사용된다.
- 네트워킹에서 모든 종류의 직렬 인터페이스를 통해 다른 시스템으로 전송되는 수많은 비트의 패킷을 구성하는 데 사용된다.
- 디지털 이미지 프로세서도 비트 연산을 사용하여 이미지를 조작한다.

## 비트연산자
비트 단위로 논리 연산을 할 때 사용하는 연산자이다.

| 비트 연산자                        | 설명                                                                     |
| --------------------------------- | ------------------------------------------------------------------------ |
| **AND 연산 ( & )**                 | 비교되는 비트가 모두 1이면 1을 반환. 아닌 경우 0을 반환                  |
| **OR 연산 ( &#124; )**             | 비교되는 비트 중 하나라도 1이면 1을 반환. 아닌 경우 0을 반환.            |
| **XOR 연산 ( ^ )**                 | 비교되는 두 비트가 다르면 1을 반환한다. 같으면 0을 반환.                 |
| **NOT 연산( ~ )**                  | 비트가 1이면 0으로, 0이면 1로 반전.                                      |
| **LEFT SHIFT 연산 ( &#60;&#60; )** | 명시된 수만큼 비트를 전부 왼쪽으로 이동시킨다.                           |
| **RIGHT SHIFT 연산( &#62;&#62; )** | 부호를 유지하며 지정한 수만큼 비트를 오른쪽으로 이동시킨다.              |
| **&#62;&#62;&#62;**                | 지정한 수만큼 비트를 전부 오른쪽으로 이동시킨다. 새로운 비트는 0이 된다. |


## 비트마스크(Bit Mask)

정수의 이진수 표현을 활용한 기법이다. 

### 비트마스크의 장점
#### 1. 수행 시간이 빠르다

비트마스크 연산은 bit 연산이라 O(1)에 구현되는 것이 많다. 따라서 다른 자료구조를 이용하는 것보다 훨씬 빠르게 동작한다. 

#### 2. 코드가 간결하다.

다양한 집합 연산들을 비트연산자로 한 줄로 작성할 수 있기 때문에 반복문이나 조건문을 사용한 코드보다 훨씬 간결하다. 

#### 3. 메모리 사용량이 적다.

하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이며, 많은 데이터들을 미리 계산하여 저장할 수 있는 장점도 있다.

### 비트마스크를 이용한 집합 구현

연산|사용 예시
-|-
**공집합과 꽉 찬 집합 구하기**|A = 0; / A = (1 << 10) - 1;
**원소 추가**|A &#124;= (1 << k);
**원소 삭제**|A &= ~(1 << k);
**원소의 포함 여부 확인**|if(A & (1 << k))
**원소의 토글(toggle)**|A ^= (1 << k);
**두 집합에 대해서 연산**|A &#124; B       → A와 B의 합집합<br>A & B     → A와 B의 교집합<br>A & (~B) → A에서 B를 뺀 차집합<br>A ^ B     → A와 B중 하나에만 포함된 원소들의 집합 
**집합의 크기 구하기**|int bitCount(int A){<br>  if(A == 0) return 0;<br>  return A%2 + bitCount(A / 2);<br>}<br><br>[내장 명령어]<br>gcc/g++ → __builtin_popcount(A) <br>visual C++ → __popcnt(A)<br>Java → Integer.bitCount(A)
**최소 원소 찾기**|int first = A & (-A);
**최소 원소 지우기**|A &= (A - 1);
**모든 부분 집합 순회하기**|for (int subset = A ; subset ; subset = ((subset - 1) & A)){ }

#### 공집합과 꽉 찬 집합 구하기
기본적으로 공집합은 bit가 모두 꺼진 상황으로 상수 0으로 표현한다. 반대로 꽉 찬 집합은 bit가 모두 켜진 상황이므로 1111111111(2)의 값으로 표현한다. 이는 (1<<10) - 1 과 동일하다.

#### 원소 추가
A 집합에 특정 원소를 추가하는 방법이다. 원소에 해당하는 bit만 켜야 하기 때문에 해당 bit를 항상 1로 만드는 연산이 필요하기 때문에 따라서 **OR 연산**을 이용한다. 

#### 원소 삭제
A 집합에 포함된 특정 원소를 삭제하는 방법이다. A에 k번째 원소의 포함 여부와 상관없이 해당 bit를 끄기 위해서는 **AND 연산**을 이용해야 한다.
- `1<<k` : k번째가 켜진 상태

- `^(1<<k)` : k번째만 꺼진 상태

- `A &= ^(1<<k);` : A 집합에 담긴 k번째 상태 off

#### 원소의 포함 여부 확인
A 집합에 특정 원소가 포함되어 있는지 확인하는 방법이다. k번째 원소가 포함되어 있는지 확인하고 싶다면, k번째 bit가 켜져 있는지만 확인하면 된다. 

#### 원소의 토글(toggle)
A 집합에 해당 원소가 빠져있는 경우에는 추가하고, 들어있는 경우에는 삭제하는 방법이다. **XOR 연산**을 이용한다.

#### 두 집합에 대해서 연산
두 집합을 A와 B라고 한다면 비트연산자들을 통해서 A와 B의 교집합, 합집합, 차집합 등을 구할 수 있다. 

#### 집합의 크기 구하기
집합에 포함된 원소의 크기를 구한다면 A에서 켜진 bit의 수를 구하면 될 것이다. 직접 모든 비트를 확인하면서 개수를 체크할 수도 있고, 내장 명령어를 이용할 수도 있다. 

#### 최소 원소 찾기
집합에 포함된 가장 작은 원소 (index가 가장 작은 원소)를 찾는 방법이다. 켜져 있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는 것이다. 비트마스크 뿐만 아니라 <u>**펜윅 트리 (Fenwick Tree)에서도 사용되는 기법**</u>이다. 

비트 A가 있다고하자. 

1. 가장 오른쪽에 켜져있는 bit를 k라고 하면, 0~k-1의 bit는 모두 0이다.
2. 그렇다면 ~A에서는 k번째 bit는 0, 0~k-1의 bit는 모두 1이다.
3. ~A + 1을 하게 되면 k번째 bit는 1, 0~k-1의 bit는 모두 0이 된다. k이후의 비트는 아무 변화가 없다.
> ~A + 1 : 컴퓨터가 표현하는 A의 2의 보수 (-A) 

따라서, -A와 A를 AND연산을 시키면 k번째 bit만 켜진 상태로 남게 된다.

    int first = A & (-A);
     
    A : 1010,
    ~A+1 (-A) : 0110,
    A&(-A) : 0010 

#### 최소 원소 지우기
가장 오른쪽에 켜져 있는 bit를 지우고 싶다면 A-1과 AND시키면 된다. A에서 1을 빼주게 되면 가장 오른쪽에 있던 bit는 0이 되고 그보다 오른쪽에 있는 모든 bit들이 1이 되기 때문이다. 

#### 모든 부분 집합 순회하기
A의 모든 부분 집합을 탐색하는 방법이다. 

### Reference 

https://en.wikipedia.org/wiki/Bit_manipulation

https://en.wikipedia.org/wiki/Bitwise_operation

https://www.educative.io/blog/bit-manipulation-algorithms

https://rebro.kr/63


